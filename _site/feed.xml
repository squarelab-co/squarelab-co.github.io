<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Square Lab</title>
    <description>새로운 시선으로 여행을 바라보는 사람들</description>
    <link>https://www.squarelab.co/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 06 Mar 2020 09:39:44 +0900</pubDate>
    <lastBuildDate>Fri, 06 Mar 2020 09:39:44 +0900</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Google Apps Script를 활용한 Slack Bot 만들기</title>
        <description>&lt;p&gt;G Suite과 Slack은 스타트업에서 필수로 사용하는 서비스라 해도 과언이 아닙니다. G Suite의 다양한 기능과 쉽게 연동이 가능한 Google Apps Script로 Slack Bot을 만들면 반복작업을 자동화하고 업무효율을 높일 수 있습니다.
오늘은 Apps Script를 활용해 Slack Bot을 만드는 기본적인 내용을 공유하고자 합니다.&lt;/p&gt;

&lt;h3 id=&quot;google-apps-script&quot;&gt;Google Apps Script&lt;/h3&gt;
&lt;p&gt;우선 새로운 Apps Script 프로젝트를 만들어야 합니다. G suite 계정의 Google Drive에서 좌측 상단의 New(새로 만들기) 버튼으로 시작하세요.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/google-drive-new.png&quot; alt=&quot;google-drive-new.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Apps Script가 만들어지면 아래 코드를 복사해 붙여넣기 합니다. Slack에서 인증을 받기 위한 내용인데 코드에 대한 설명은 Slack App 부분에서 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function doPost(e) {
    return ContentService.createTextOutput(JSON.parse(e.postData.contents).challenge);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/google-apps-script-new.png&quot; alt=&quot;google-apps-script-new.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;코드를 붙여넣기 했으면 메뉴 &amp;gt; Publish &amp;gt; Deploy as web app을 선택합니다. 이때 Slack이 Apps Script에 접근할 수 있도록 팝업 하단의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Who has access to the app&lt;/code&gt;의 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Anyone, even anonymous&lt;/code&gt;로 선택하고 Deploy합니다.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/google-apps-script-deploy.png&quot; alt=&quot;google-apps-script-deploy.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Deploy가 완료되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Current web app URL&lt;/code&gt;이 표시됩니다. 곧 필요할테니 미리 복사해두세요.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/google-apps-script-deployed.png&quot; alt=&quot;google-apps-script-deployed.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slack-app&quot;&gt;Slack App&lt;/h3&gt;
&lt;p&gt;이제 Slack App을 만들 차례입니다. Slack API 사이트의 &lt;a href=&quot;https://api.slack.com/apps&quot;&gt;Your Apps&lt;/a&gt; 페이지에서 Create New App 버튼을 클릭하면 아래와 같은 팝업이 열립니다.
App에게 적당한 이름을 지어주고 연결할 Workspace를 선택하세요. App과 Bot의 용어가 혼란스러울 수 있는데 App의 기능 중 하나가 Bot이라고 이해하시면 됩니다.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-api-create-new-app.png&quot; alt=&quot;slack-api-create-new-app.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Slack App이 만들어지면 Basic Information 페이지로 이동됩니다. 이제 Slack App과 Apps Script를 연결할 차례입니다. Add features and functionality 섹션의 Event Subscriptions 버튼을 클릭하세요.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-api-basic-information.png&quot; alt=&quot;slack-api-basic-information.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Enable Events 스위치를 &lt;code class=&quot;highlighter-rouge&quot;&gt;On&lt;/code&gt;하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Request URL&lt;/code&gt;이 표시되는데 여기에 Apps Script에서 복사해두었던 &lt;code class=&quot;highlighter-rouge&quot;&gt;Current web app URL&lt;/code&gt;을 붙여넣기 하세요. 이제 눈치채셨겠지만 아까 작성한 코드는 Slack이 보내준 &lt;code class=&quot;highlighter-rouge&quot;&gt;challenge&lt;/code&gt; parameter를 다시 return해 인증을 받는 내용이었습니다.&lt;/p&gt;

&lt;p&gt;코드에 문제가 없고 Deploy도 정상적으로 되었다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Verified&lt;/code&gt;가 표시될 겁니다. 이제 Slack App이 추가된 채널에 메시지가 포스팅되면 Event를 수신할 수 있도록 Subscribe to bot events에 &lt;code class=&quot;highlighter-rouge&quot;&gt;message.channels&lt;/code&gt;를 추가하세요. 
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-app-event-subscriptions.png&quot; alt=&quot;slack-app-event-subscriptions.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Basic Information으로 돌아와서 이번에는 Add features and functionality 섹션의 Permissions를 선택합니다.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-api-basic-information2.png&quot; alt=&quot;slack-api-basic-information2.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이제 Slack App에게 적절한 권한을 주어야 할 차례입니다. OAuth &amp;amp; Permissions에서 스크롤을 내리면 Scopes 섹션을 찾을 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;channels:history&lt;/code&gt;는 먼저 등록한 Event 수신을 위한 필수 권한이라 이미 추가되어 있습니다.&lt;/p&gt;

&lt;p&gt;여러분이 만들 Bot 따라 다양한 권한이 필요하겠지만 일단 여기서는 제대로 동작하는지 확인할 용도로 &lt;code class=&quot;highlighter-rouge&quot;&gt;reactions:write&lt;/code&gt;만 추가했습니다.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-api-scopes.png&quot; alt=&quot;slack-api-scopes.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;다시 스크롤을 올려 Workspace에 App을 설치해야 합니다. Install App to Workspace 버튼을 클릭하면 Workspace에 App이 설치되고 Bot User OAuth Access Token을 얻게 됩니다. 이것도 곧 필요해질테니 일단 복사해두세요.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-api-install-app.png&quot; alt=&quot;slack-api-install-app.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;apps-script-업데이트-하기&quot;&gt;Apps Script 업데이트 하기&lt;/h3&gt;
&lt;p&gt;이쯤되면 뭔가 귀찮아지고 손가락은 command + W에 올라가 있겠지만 거의 다 끝났으니 포기하지 마세요. 다시 Apps Script로 돌아가 코드를 수정할게요. &lt;code class=&quot;highlighter-rouge&quot;&gt;challenge&lt;/code&gt; parameter를 return하던 코드는 더이상 필요하지 않으니 삭제하고 아래 내용으로 바꿔줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function doPost(e) {
  var token = &quot;xxxx-xxxxxxxxx-xxxx&quot;;
  var contents = JSON.parse(e.postData.contents);
  var option = {
    'method' : 'post',
    'payload' : {
      'token': token,
      'channel': contents.event.channel,
      'timestamp': contents.event.ts,
      'name': &quot;heavy_check_mark&quot;
    }
  };
  UrlFetchApp.fetch(&quot;https://slack.com/api/reactions.add&quot;, option);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Slack에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;message.channels&lt;/code&gt; Event가 수신되면 &lt;a href=&quot;https://api.slack.com/events/message.channels&quot;&gt;예제&lt;/a&gt;와 같이 데이터를 전달 받습니다.
Slack으로부터 받은 데이터에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;channel&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;timestamp&lt;/code&gt;를 사용해 해당 메시지에 체크 이모지를 달아주는 코드입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;에는 앞서 복사해두었던 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bot User OAuth Access Token&lt;/code&gt; 값을 넣어주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;모두 적용했으면 다시 Deploy 해야합니다. 팝업에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Project version&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;New&lt;/code&gt;로 선택하고 Update 버튼을 클릭합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;UrlFetchApp&lt;/code&gt;을 사용했기 때문에 권한을 요청하는 팝업이 열릴텐데 흔쾌히 허용해주세요.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/google-apps-script-update.png&quot; alt=&quot;google-apps-script-update.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;채널에-slack-app-추가하기&quot;&gt;채널에 Slack App 추가하기&lt;/h3&gt;
&lt;p&gt;드디어 Slack Bot이 잘 동작하는지 확인할 차례입니다. Slack으로 넘어와 방금 만든 App을 채널에 추가해 보겠습니다. 테스트 채널을 하나 만들고 우측의 Add App 버튼으로 방금 만든 App을 검색해 추가합니다.
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-add-app.png&quot; alt=&quot;slack-add-app.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자, 이제 테스트 채널에 메시지를 보내보세요. Slack Bot이 메시지를 확인하면 바로 체크 이모지를 붙여줄겁니다!
&lt;img src=&quot;/images/post/how-to-make-a-slack-bot/slack-add-reaction.png&quot; alt=&quot;slack-add-reaction.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;
&lt;p&gt;Apps Script를 활용해 Slack Bot을 만드는 기본적인 내용은 여기까지입니다. 이제 여러분이 직접 필요한 Bot을 만들어 나가면 됩니다. 채널에 올라온 메시지의 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;contents.event.text&lt;/code&gt;에 있으니 적절히 파싱해 필요한 작업을 수행하게 하세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function doPost(e) {
  var token = &quot;xxxx-xxxxxxxxx-xxxx&quot;;
  var contents = JSON.parse(e.postData.contents);
  
  if (contents.event.text == &quot;something&quot;)
  {
     //Do something!
  }
  
  var option = {
    'method' : 'post',
    'payload' : {
      'token': token,
      'channel': contents.event.channel,
      'timestamp': contents.event.ts,
      'name': &quot;heavy_check_mark&quot;
    }
  };
  UrlFetchApp.fetch(&quot;https://slack.com/api/reactions.add&quot;, option);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스퀘어랩에서도 여러 Slack Bot을 만들어 활용하고 있는데요. 휴가와 리모트 근무를 알리는 leave 채널에서는 Calendar Bot이 메시지를 파싱해 캘린더에 자동으로 일정을 추가해주고 jukebox 채널의 Music Bot은 사무실의 DJ로 활약하고 있습니다.&lt;/p&gt;

&lt;p&gt;Slack Bot을 직접 만들지 않더라도 &lt;a href=&quot;https://ifttt.com/&quot;&gt;IFTTT&lt;/a&gt;나 &lt;a href=&quot;https://zapier.com/home&quot;&gt;Zapier&lt;/a&gt;을 사용하는 방법도 있는데요. 이런 서비스들을 쓰는 것 보다 직접 만들었을 때의 장점은 자유도가 높고 고도화가 가능하다는 점입니다.
&lt;a href=&quot;https://developers.google.com/apps-script/api&quot;&gt;Apps Script API&lt;/a&gt;와 &lt;a href=&quot;https://api.slack.com/&quot;&gt;Slack API&lt;/a&gt;에서 어떤 것들이 가능한지 살펴보세요.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Mar 2020 00:00:00 +0900</pubDate>
        <link>/blog/how-to-make-a-slack-bot/</link>
        <guid isPermaLink="true">/blog/how-to-make-a-slack-bot/</guid>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Square Lab 브랜딩 프로젝트</title>
        <description>&lt;p&gt;트렌디한 여행 서비스 &lt;a href=&quot;https://www.playwings.co.kr/about&quot;&gt;플레이윙즈&lt;/a&gt;와 &lt;a href=&quot;https://kyte.travel/&quot;&gt;카이트&lt;/a&gt;를 만드는 ‘스퀘어랩’. 우리만의 브랜드 아이덴티티가 필요했습니다. 단순한 로고 제작이 아닌 회사의 컬러를 만들어 갔던 스퀘어랩의 브랜딩 경험을 공유합니다.&lt;/p&gt;

&lt;h2 id=&quot;스퀘어랩-정의하기&quot;&gt;스퀘어랩 정의하기&lt;/h2&gt;

&lt;p&gt;“스퀘어랩은 무엇일까?”, “스퀘어랩은 무엇을 할까?” 브랜딩을 위해 모인 TFT 멤버들은 스퀘어랩의 모습을 만들기 전, 고민에 고민을 거쳐 하나하나 우리와 맞는 것들을 찾아 나갔습니다. 우리가 누군지를 알아야 우리에게 맞는 옷을 입을 수 있으니까요.&lt;/p&gt;

&lt;h3 id=&quot;여행을-가볍게-하는-사람들&quot;&gt;여행을 가볍게 하는 사람들&lt;/h3&gt;

&lt;p&gt;스퀘어랩의 서비스인 플레이윙즈, 카이트는 특가 항공권 알림, 일정에 맞는 여행지 추천 등으로 사용자가 언제든 가볍게 여행을 떠날 수 있게 합니다. 또한 스퀘어랩만의 기술로 사용자가 여행을 준비하고, 떠나는 모든 과정이 즐거울 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;여행에 대한 새로운 시각을 만들고, 경험이 확장될 수 있도록 하는 것. 그것이 바로 스퀘어랩이고, 스퀘어랩의 일이라고 정의했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/square-lab-branding/post1_inspire.gif&quot; alt=&quot;post1_inspire.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스퀘어랩에는-어떤-사람들이-일하고-있을까&quot;&gt;스퀘어랩에는 어떤 사람들이 일하고 있을까?&lt;/h3&gt;

&lt;p&gt;스퀘어랩의 역할을 정한 후, 이제 “스퀘어랩 멤버는 무엇일까?”에 대해 고민했습니다. 결국 스퀘어랩의 색채를 만들어 가는 건 우리들이니까요. 우리는 어떻게 일하는 사람들인가, 우리가 만들어 내는 스퀘어랩의 모습은 어떤 모습이어야 할까, 고민 끝에 스퀘어랩의 브랜드 에센스를 세 가지로 정리했습니다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Youthful:&lt;/strong&gt; 젊고 자유롭게 일하면서 여행의 트렌드를 빠르게 파악하고, 새로움을 받아들여 우리의 서비스에 녹아냅니다.&lt;br /&gt;
&lt;strong&gt;Professional:&lt;/strong&gt; 자유로움 속에서도 있는 분명한 책임으로 업무를 수행하는 전문가들입니다.&lt;br /&gt;
&lt;strong&gt;Expansion:&lt;/strong&gt; 주도적인 태도로 개인과 스퀘어랩을 다양한 영역에 확장합니다.&lt;/p&gt;

&lt;p&gt;젊은 감각과 전문적인 기술, 주도적인 자율과 책임으로 일하며 자신의 역량과 스퀘어랩을 함께 확장하는 사람들, 그것이 스퀘어랩이 갖고있는 우리만의 아이덴티티입니다.
&lt;img src=&quot;/images/post/square-lab-branding/post2_keyword.png&quot; alt=&quot;post2_keyword.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;왜-스퀘어랩일까&quot;&gt;왜 스퀘어랩일까?&lt;/h2&gt;

&lt;p&gt;그럼, 이제는 우리의 가치를 담아낸 메타포가 필요합니다. 직각으로 이뤄진 이 정사각 도형은 명확하고, 직관적이지만 얼마든지 기하학적으로 조형할 수 있습니다.
누구나 쉽게 접근할 수 있지만, 그 안에서 자기만의 멋을 가지는 것, 마치 자기만의 색채를 가지고 싶어 하는 젊은 트렌드와 닮아있습니다.
&lt;img src=&quot;/images/post/square-lab-branding/post3_square_shape.png&quot; alt=&quot;post3_square_shape.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 스퀘어가 가지고 있는 ‘제곱’, ‘광장’이라는 다른 사전적 의미는 ‘가치의 확장과 성장’, ‘다양한 환경과 문화를 담아내는 공간’이 되고 이러한 개념들이 결국은 ‘전문적인 기술을 가진 집단’이라는 Lab과 합쳐져 Square Lab이 됐습니다.&lt;/p&gt;

&lt;h2 id=&quot;의미를-형태로-철학을-실체로&quot;&gt;의미를 형태로, 철학을 실체로&lt;/h2&gt;

&lt;p&gt;아이덴티티도 정하고 이름도 만들었으니 구체적인 스퀘어랩 형태를 만드는 인고의 시간(?)이 시작됐습니다. 모든 브랜딩 작업이 그러하듯 브랜딩 TFT는 스퀘어랩 BI 시안을 만들고, 또 만들고, 계속 만들었습니다. 스퀘어랩이 어떤 형태면 좋을지에 대한 설문과 내부 피드백을 통해 Logo Shape과 Typeface, Color를 정하고 발전시켜 스퀘어랩의 BI를 만들어 갔습니다.
&lt;img src=&quot;/images/post/square-lab-branding/post4_prototype.png&quot; alt=&quot;post4_prototype.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여러 과정을 걸쳐 최종으로 완성된 BI는 아래와 같은 모습입니다. (만들어졌던 모든 시안에 안녕과 감사를…)이 안에 들어와 있는 요소들은 어떤 의도와 의미가 있는지 하나하나 뜯어보겠습니다.
&lt;img src=&quot;/images/post/square-lab-branding/post5_bi_Final.png&quot; alt=&quot;post5_bi_Final.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-logo-shape&quot;&gt;1. Logo Shape&lt;/h3&gt;

&lt;p&gt;로고를 구성하는 형태는 스퀘어로 잡았습니다. 우리는 스퀘어랩이니까요. 여기에 정사각형의 조형적인 형태에 확장성을 더하고 싶었습니다. 두 개의 꺽쇠 형태가 합쳐진 형태는 공간과 사용자를 이어주는 프레임 역할을 하고 나아가 공간의 확장, 사용자의 시각과 경험의 확장을 의미하게 됩니다.
&lt;img src=&quot;/images/post/square-lab-branding/post6_logo_shape.gif&quot; alt=&quot;post6_logo_shape.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-typeface&quot;&gt;2. Typeface&lt;/h3&gt;
&lt;p&gt;스퀘어랩에 브랜딩 아이덴티티 안에 ‘Square Lab’이라는 문자는 명확하고 직관적일 필요가 있었습니다. 이를 위해 다양한 Typeface들을 테스트했지만 조금씩 부족한 어떤 것을 채울 수가 없어 직선과 정원으로 조형된 ‘Square Sans’를 제작했습니다. Square와 Lab 두 단어 사이에 볼륨을 다르게 구성해, 로고 형태에 조형미를 높였습니다.
&lt;img src=&quot;/images/post/square-lab-branding/post7_typeface.png&quot; alt=&quot;post7_typeface.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-color&quot;&gt;3. Color&lt;/h3&gt;

&lt;p&gt;로고의 형태와 Typeface가 직관적이고 명확했다면 여행이라는 키워드가 주는 감성적인 부분을 컬러로 채웠습니다. 해가 지는 절정의 순간을 모티브 한 보라색 그라디언트 컬러는 사용자의 깊은 경험과 감각적이면서 감성적인 톤앤매너를 가지게 합니다.
&lt;img src=&quot;/images/post/square-lab-branding/post8_color.jpg&quot; alt=&quot;post8_color.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;브랜드-확장-시키기&quot;&gt;브랜드 확장 시키기&lt;/h2&gt;

&lt;p&gt;스퀘어랩의 철학적 의미와 브랜드 컬러가 담긴 BI는 이렇게 탄생했습니다. BI를 통해 만들어진 Shape, Typeface, Color들이 단순히 BI를 위한 것이 아니라 스퀘어랩 브랜드 경험을 유기적으로 확장하는 메타포로 굿즈와 이미지들에 활용하고 있습니다. 여러 가지로 확장한 케이스들을 다음 포스팅에서 공유하도록 하겠습니다.
&lt;img src=&quot;/images/post/square-lab-branding/post9_goods.png&quot; alt=&quot;post9_goods.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;브랜딩 과정을 마치고 공식적으로 다양한 상황과 형태로 활용되는 것을 보고 나니, 제법 스퀘어랩이라는 브랜드가 그 안에 있는 우리들과 닮아가고 있다 생각이 드네요.&lt;/p&gt;

&lt;p&gt;스퀘어랩에 브랜딩 과정은 끝이 아니라 지금, 이 순간에도 우리가 만들어가는 과정 같습니다. 새롭거나 재미있게 만들어질 스퀘어랩을 계속 기대해주세요.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Mar 2020 00:00:00 +0900</pubDate>
        <link>/blog/square-lab-branding/</link>
        <guid isPermaLink="true">/blog/square-lab-branding/</guid>
        
        
        <category>Design</category>
        
      </item>
    
      <item>
        <title>Cloudinary를 활용한 이미지 컨텐츠 관리</title>
        <description>&lt;p&gt;새로운 서비스를 만들때 이미지 컨텐츠를 관리하는 것은 디자이너에게 매우 중요한 문제입니다. 디자인이 아무리 잘되어 있어도 컨텐츠가 적절한 퀄리티로 노출되지 않으면 디자인의 품질이 떨어져 보이고 사용자에게 신뢰감을 주기 어렵기 때문입니다.&lt;/p&gt;

&lt;p&gt;그렇다고 모든 이미지 컨텐츠를 하나하나 디자이너가 직접 관리하기에는 리소스가 너무 많이 들지요. 이 포스트에서는 스퀘어랩이 Cloudinary를 활용해 어떻게 이미지 컨텐츠를 관리하고 있는지 공유합니다.&lt;/p&gt;

&lt;h2 id=&quot;cloudinary-소개&quot;&gt;Cloudinary 소개&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloudinary.com/&quot;&gt;Cloudinary&lt;/a&gt;는 클라우드 기반의 이미지 및 비디오 관리 서비스입니다. 강력하면서 쉬운 API를 제공하고 있어 조금만 익숙해지면 컨텐츠를 매우 효율적으로 관리할 수 있습니다. 그리고 무엇보다 무료로 시작할 수 있어 스타트업에서 도입하기에 부담이 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;데모-이미지&quot;&gt;데모 이미지&lt;/h3&gt;
&lt;p&gt;Cloudinary에 가입하고 이미지를 업로드 하는 것은 어렵지 않습니다. 일반적인 CDN이나 웹서버의 사용법과 유사하죠. 이미지를 업로드하면 고유한 URL을 얻을 수 있는데, 예제로 사용하기 위해 Cloudinary에서 데모로 제공하고 있는 이미지 중에서 고양이 사진을 하나 골라봤습니다. 고양이는 언제나 옳으니까요.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원본은 3940x2540 사이즈에 용량은 1.6MB인 고화질 이미지입니다. 일반적인 웹이나 앱 서비스에서 이런 고화질 이미지를 사용하는 경우는 거의 없습니다. 그래서 상황에 맞게 디자이너들이 직접 이미지를 리사이징하거나 CDN에서 API를 제공하는 경우 API를 통해 동적으로 리사이징해 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-리사이징&quot;&gt;이미지 리사이징&lt;/h3&gt;
&lt;p&gt;Cloudinary에서는 URL 파라미터를 통해 쉽게 이미지를 리사이징 할 수 있습니다. 바로 예제를 살펴볼까요.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;크고 무거웠던 원본 이미지에서 400x258 사이즈에 용량은 25KB로 줄어든 이미지를 확인할 수 있습니다. URL에서 어떤 부분이 달라졌는지 눈치 채셨나요? &lt;code class=&quot;highlighter-rouge&quot;&gt;sofa_cat.jpg&lt;/code&gt; 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;width=400&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;w_400&lt;/code&gt; 파라미터를 붙여 원본을 기준으로 비율에 맞게 가로 400px로 줄어든 이미지를 얻을 수 있습니다. CSS로 원본 이미지를 줄여서 표시한게 아니라 jpg 파일 자체의 사이즈와 용량이 줄어들었다는 점이 중요합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,h_400/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,h_400/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물론 세로 사이즈도 원하는 대로 지정할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;height=400&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;h_400&lt;/code&gt; 파라미터를 추가하면 위와 같이 이미지가 표시됩니다. 비율에 맞지 않는 사이즈를 입력했기 떄문에 이미지가 강제로 줄어들어 고양이가 좀 놀란 것 같네요.&lt;/p&gt;

&lt;h3 id=&quot;이미지-크롭핑&quot;&gt;이미지 크롭핑&lt;/h3&gt;
&lt;p&gt;원본 비율과 다른 사이즈가 필요할 때는 이미지가 왜곡되어 보이지 않도록 이미지를 크롭해야 합니다. Cloudinary에서는 리사이징과 마찬가지로 URL 파라미터를 통해 쉽게 이미지를 크롭할 수 있습니다.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crop to fill&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;c_fill&lt;/code&gt;이 추가되었습니다. 이제 이미지 왜곡없이 400x400으로 이미지를 표시할 수 있게 되었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,ar_1:1,c_fill/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,ar_1:1,c_fill/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;세로 길이를 지정하는 대신 비율을 직접 입력할 수도 있습니다. 1:1 비율로 표시하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;h_400&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;aspect ratio=1:1&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ar_1:1&lt;/code&gt;을 사용해 볼까요? &lt;code class=&quot;highlighter-rouge&quot;&gt;h_400&lt;/code&gt;를 추가했을 때와 동일한 결과를 확인할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;16:9&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;4:3&lt;/code&gt;등 원하는 비율대로 표시할 수 있지요.&lt;/p&gt;

&lt;h3 id=&quot;오브젝트-중심의-이미지-크롭핑&quot;&gt;오브젝트 중심의 이미지 크롭핑&lt;/h3&gt;
&lt;p&gt;하지만 계속 왼쪽으로 쏠려있는 고양이가 마음 쓰이셨죠? 파라미터를 하나 더 추가해서 이 문제를 해결할 수 있습니다.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill,g_auto/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill,g_auto/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번에 추가된 파라미터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;grtavity&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;로 적용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;g_auto&lt;/code&gt;입니다. 직역하자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;중력 자동 적용&lt;/code&gt; 정도로 해석할 수 있는데요. Cloudinary에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;grtavity&lt;/code&gt; 파라미터로 이미지에 포함된 얼굴이나 사물을 자동으로 인식해 오브젝트를 안정적으로 표시할 수 있는 기능을 제공하고 있습니다. 다양한 오브젝트가 포함된 이미지가 아니라면 인식률도 높아서 사용하는데 무리가 없습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한쪽으로 긴 사이즈의 이미지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;grtavity&lt;/code&gt; 성능을 확인해 볼까요? 위 이미지 처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;g_auto&lt;/code&gt; 파라미터가 없으면 이미지의 가운데를 기준으로 크롭핑되어 고양이의 얼굴이 이미지 밖으로 벗어나고 맙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;g_auto&lt;/code&gt; 파라미터를 넣어주면 가로나 세로로 긴 사이즈의 이미지를 요청하더라도 오브젝트를 기준으로 크롭핑 되어 반가운 고양이의 얼굴을 볼 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-최적화&quot;&gt;이미지 최적화&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto,q_auto/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto,q_auto/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;quality=auto&lt;/code&gt;를 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;q_auto&lt;/code&gt;를 추가해보겠습니다. Cloudinary의 설명에 따르면 이미지 용량과 비주얼 퀄리티 사이에서 최적의 밸런스를 찾아준다고 합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;q_auto&lt;/code&gt;를 추가하기 전 이미지의 용량은 19KB였지만 추가한 후에는 7KB로 크게 줄었습니다. 매의 눈을 가진 분이라면 줄어든 용량 만큼 퀄리티가 다소 낮아진 것을 발견했겠지만 앞서의 설명대로 그렇게 크게 차이 나지는 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto,q_auto:best/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto,q_auto:best/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼에도 불구하고 더 나은 퀄리티를 원한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;q_auto&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;best&lt;/code&gt; 옵션을 추가해 가장 좋은 퀄리티로 최적화할 수 있습니다. 용량은 10KB로 늘어났지만 조금 더 나아진 퀄리티를 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;맺음말&quot;&gt;맺음말&lt;/h3&gt;
&lt;p&gt;지금까지 예제와 함께 Cloudinary를 활용한 이미지 컨텐츠 관리에 대해 살펴보았습니다.&lt;/p&gt;

&lt;p&gt;스퀘어랩에서는 하나의 이미지를 여러 화면에서 다른 크기로 표시할 때, 배너 이미지를 다양한 사이즈로 제작할 때 Cloudinary를 적극 사용하고 있습니다. 이를 통해 디자이너들은 이미지를 리사이징하는 반복작업에서 벗어나 더 창조적인 업무에 집중할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;Cloudinary에는 위에 언급 된 내용보다 더 많은 기능이 있으니 자세한 내용은 &lt;a href=&quot;https://cloudinary.com/documentation/image_transformations&quot;&gt;Get Started with Cloudinary&lt;/a&gt;를 참고하세요.&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Feb 2020 00:00:00 +0900</pubDate>
        <link>/blog/get-started-with-cloudinary/</link>
        <guid isPermaLink="true">/blog/get-started-with-cloudinary/</guid>
        
        
        <category>Design</category>
        
      </item>
    
      <item>
        <title>Serverless한 회사 내부 서비스 만들기</title>
        <description>&lt;p&gt;사내에서 사용되는 서비스의 경우 대중을 대상으로 하지 않기 때문에 사용량이 많지 않은 경우가 대부분입니다. AWS Lambda를 사용하면 비용 절감뿐만 아니라 서버를 직접 관리하고 운영할 필요도 없기 때문에 안정적이고 편리합니다. Lambda에서는 warm up 전의 첫 호출시 응답이 느린 cold start 문제가 있긴하지만 오히려 사내 서비스의 경우 상대적으로 유저경험이 덜 중요하기때문에 cold start시에 잠깐 응답이 느려지는 것 정도는 큰 문제가 되지 않습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이제 실제로 serverless 형태로 회사 내부 서비스를 만들기 위해 어떻게 해야하는지 좀 더 깊은 고민을 해보도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;serverless-framework-소개&quot;&gt;Serverless framework 소개&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/developing-internal-service-with-serverless-aws/serverless-framework.jpg&quot; alt=&quot;serverless-framework.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AWS Lambda + AWS API Gateway를 이용하여 직접 서버 인스턴스를 띄우지 않고서도 서버 기능을 할 수 있다는 사실은 많이 알려져 있습니다. 하지만 막상 이걸 직접 설정 해보려고 하면 해야할 일이 산더미 같습니다. 실제 코드를 작성해서 Lambda에 업로드해야하고, Lambda를 누가 실행 할 수 있는지 적당한 권한을 설정해줘야 하며, API Gateway와 Lambda를 연결해줘야하고, 사용자 지정 도메인도 연결해줘야하며, CloudWatch 로그 설정도 … (중략). 슬슬 오히려 EC2 인스턴스를 그냥 띄워서 하던대로 하는게 낫지 않을까 생각이 들기 시작하네요.&lt;/p&gt;

&lt;p&gt;하지만 위와 같은 AWS 웹 콘솔을 통한 복잡하고 반복적인 설정/배포 과정 대신 &lt;a href=&quot;https://serverless.com/&quot;&gt;serverless framework&lt;/a&gt;를 사용하면 설정 파일 하나로 언제든지 손쉽게 환경 생성/재배포가 가능해지고 해당 설정 내용을 소스 저장소에 올려서 공유 및 변경 내용 추적까지 가능합니다.&lt;/p&gt;

&lt;p&gt;serverless framework CLI를 설치한 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 설정 파일을 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;sls deploy&lt;/code&gt; 명령어만 실행하면 설정파일에 정의된 대로 자동으로 서비스 설정/배포가 완료됩니다. (설정 파일의 실제 내용이 궁금한 분들은 글 제일 아래쪽의 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 샘플 섹션을 참고)&lt;/p&gt;

&lt;p&gt;Serverless framework의 경우 내부적으로 AWS CloudFormation 기능을 이용하여 Lambda, API Gateway의 자잘한 설정들을 변경하게되는데, AWS 콘솔을 통해서 변경 가능한 설정 항목들은 serverless framework의 설정파일에서도 거의 지원하고있다고 보면 됩니다. (심지어 AWS뿐만아니라 Azure, Google Cloud 등의 다른 cloud provider도 지원)&lt;/p&gt;

&lt;p&gt;Serverless framework을 이용해서 골치아픈 인프라 설정 문제는 어느정도 해결되었으니, 어떻게하면 회사 내부 서비스에 적합한 구성을 할 수 있을지에 대해서 고민해 봐야할 차례입니다.&lt;/p&gt;

&lt;h2 id=&quot;api-gateway를-어떻게-설정할-것인가&quot;&gt;API Gateway를 어떻게 설정할 것인가?&lt;/h2&gt;

&lt;p&gt;API Gateway의 경우 원래 Public API만 제공되었는데 2018년 6월 이후로는 설정된 VPC에서만 접근가능하도록 할 수 있는 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/compute/introducing-amazon-api-gateway-private-endpoints/&quot;&gt;Private API 기능&lt;/a&gt;이 새롭게 제공되기 시작했습니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 AWS Lambda + API Gateway를 조합하여 사내 서비스들에 사용하기 적합한 형태인&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VPC에서만 액세스 가능한 Private API를 만드는 방법&lt;/li&gt;
  &lt;li&gt;Public API 이지만 Gateway에 API 인증키를 추가해서 접근 제한을 하는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두가지에 대해 각각 알아보려고 합니다.&lt;/p&gt;

&lt;p&gt;위 방법들을 설명하기 전에 먼저 API Gateway 엔드포인트 유형에따라 어떤 차이점들이 있는지를 먼저 정리해보면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Edge (or Edge optimized)
    &lt;ul&gt;
      &lt;li&gt;CloudFront CDN&lt;/li&gt;
      &lt;li&gt;Public network에서 요청 &amp;gt; CloudFront &amp;gt; API Gateway &amp;gt; Lambda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Regional
    &lt;ul&gt;
      &lt;li&gt;CDN없는 일반적인 public API&lt;/li&gt;
      &lt;li&gt;Public network에서 요청 &amp;gt; API Gateway &amp;gt; Lambda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Private
    &lt;ul&gt;
      &lt;li&gt;엔드포인트를 생성한 VPC내에서만 접근 가능&lt;/li&gt;
      &lt;li&gt;Public network에서 요청 &amp;gt; 연결 불가&lt;/li&gt;
      &lt;li&gt;사용자 VPC내에서 요청 &amp;gt; VPC Endpoint &amp;gt; API Gateway &amp;gt; Lambda&lt;/li&gt;
      &lt;li&gt;주의: &lt;a href=&quot;https://stackoverflow.com/questions/56540149/how-do-i-define-a-custom-domain-name-for-my-amazon-api-gateway-api-with-private&quot;&gt;Private 엔드포인트는 API Gateway에 사용자 지정 도메인 (custom domain) 연결 불가&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자신의 현재 Endpoint가 어떤 유형으로 설정 되어있는지 확인하려면 API Gateway의 메인 페이지에 방문해서 API목록 중에서 “엔드포인트 유형” 컬럼을 확인하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;1-private-엔드포인트를-이용한-내부서비스-구성&quot;&gt;1. Private 엔드포인트를 이용한 내부서비스 구성&lt;/h3&gt;

&lt;p&gt;API Gateway는 AWS가 관리하는 서비스 (AWS fully-managed) 이기때문에 사용자의 VPC와는 다른 공간에 있습니다. 때문에 Private 형태로 Endpoint를 만들어 준 경우 API Gateway의 네트워크와 사용자의 VPC가 통신할 수 있도록 허용하는 설정이 필요합니다. “VPC Endpoint”가 바로 이 연결을 가능하게 해주는 설정입니다.&lt;/p&gt;

&lt;h4 id=&quot;vpc-endpoint-설정-하기&quot;&gt;VPC Endpoint 설정 하기&lt;/h4&gt;

&lt;p&gt;VPC &amp;gt; Endpoint 메뉴로 이동하면 엔드포인트를 추가 할 수 있습니다. 아래 순서대로 설정해 나가면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의:&lt;/strong&gt; 이부분은 serverless.yaml에서 지원하지 않기때문에 AWS 콘솔을 통해서 진행해야함.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VPC &amp;gt; API Gateway 연결
    &lt;ul&gt;
      &lt;li&gt;VPC Endpoint의 경우 API Gateway뿐만 아니라 AWS의 다른 관리형 서비스들에도 설정해서 사용하는 것이 가능하기때문에 다양한 서비스 목록들이 노출됩니다. API Gateway와 연결하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;com.amazonaws.{REGION}.execute-api&lt;/code&gt; 을 찾아서 선택하면 됩니다.&lt;/li&gt;
      &lt;li&gt;ex) com.amazonaws.ap-northeast-1.execute-api&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VPC 중 어떤 Subnet의 연결을 허용할지 설정
    &lt;ul&gt;
      &lt;li&gt;가용 영역별로 연결을 허용할 원하는 subnet을 선택하면 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프라이빗 DNS 이름 활성화
    &lt;ul&gt;
      &lt;li&gt;“프라이빗 DNS 이름 활성화” 가 되어있으면 기존 Public한 API Gateway &amp;gt; Lambda에서 액세스하던것과 동일한 형태의 URL로 VPC내에서 접근이 가능합니다.
        &lt;ul&gt;
          &lt;li&gt;URL 형식: https://{API_ID}.execute-api.{region}.amazonaws.com&lt;/li&gt;
          &lt;li&gt;ex) https://qb53b9muav2.execute-api.ap-northeast-1.amazonaws.com&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;주의&lt;/strong&gt;: 프라이빗 DNS를 활성화 된 엔드포인트 설정이 완료되면 해당 &lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/api-gateway-vpc-connections/&quot;&gt;VPC에서 사용자 지정 도메인(custom domain)이 설정되지 않은 기존 Public(Edge/Regional) API Gateway로의 API 호출시 HTTP 403 Forbidden 이 발생&lt;/a&gt;합니다.
        &lt;ul&gt;
          &lt;li&gt;예를들어 VPC내에서 &lt;strong&gt;Regional 또는 Edge&lt;/strong&gt;로 설정된 API GW의 엔드포인트인 https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com/prod/example 로 요청시 403 Forbidden 발생&lt;/li&gt;
          &lt;li&gt;하지만 “API GW Console &amp;gt; 사용자 지정 도메인” 메뉴를 사용하여 위 엔드포인트를 사용자 지정 도메인에 연결 후, VPC내에서 사용자 지정 도메인을 이용한 주소 (https://myservice.com/example)로 요청시  오류가 발생하지 않음&lt;/li&gt;
          &lt;li&gt;따라서 기존에 Public하게 API Gateway를 사용하는 서비스가 있고, 해당 서비스를 VPC에서 내부에서 호출하고 있다면, VPC엔드포인트를 설정하기 전에 꼭 해당 서비스들에 사용자 지정 도메인을 연결 완료해야 문제가 없음&lt;/li&gt;
          &lt;li&gt;이런 현상이 발생하는 자세한 원인에 관해서는 &lt;a href=&quot;https://st-g.de/2019/07/be-careful-with-aws-private-api-gateway-endpoints&quot;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안그룹 설정 필요
    &lt;ul&gt;
      &lt;li&gt;VPC Endpoint &amp;gt; API Gateway로 전달되는 요청은 보통 HTTP 요청이니 inbound 443, 80 포트를 허용하는 보안그룹을 추가해 주면 됩니다. 별도로 다른 프로토콜이나 포트를 사용하고있다면 해당 포트를 허용하도록 설정해주면 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt;: VPC Endpoint의 경우 &lt;strong&gt;생성 후 사용하지 않더라도 계속 요금이 발생&lt;/strong&gt;합니다. 자세한 내용은 글 마지막의 “요금 분석” 섹션을 참고 하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;api-gateway에서-api-생성-하기&quot;&gt;API Gateway에서 API 생성 하기&lt;/h4&gt;

&lt;p&gt;API Gateway 콘솔에서 API 생성시 REST API (Private) 으로 되어있는 것을 선택해서 생성하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt;를 사용할 경우 provider.endpointType 항목을 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; 으로 설정하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;특정-vpc에서만-접근되도록-설정&quot;&gt;특정 VPC에서만 접근되도록 설정&lt;/h4&gt;

&lt;p&gt;여러개의 VPC를 사용중인경우 그중 원하는 VPC에서만 Internal API가 호출되도록 허용하고 싶은 경우가 있습니다. 이경우 API Gateway의 리소스 정책 메뉴에서 “소스 VPC 화이트리스트” 버튼을 눌러 정책 템플릿을 로드한 후 원하는 vpcID만 넣어주면 됩니다. API GW의 경우 “리소스 정책” 설정 변경 후 항상 deploy를 눌러줘야 반영이 되니 주의가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 를 사용할 경우 provider.resourcePolicy에 해당 정책을 yaml형태로 넣어주면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;참고-1-vpn-연결을-통해서-vpc의-내부의-private-api-접근하기&quot;&gt;참고 1: VPN 연결을 통해서 VPC의 내부의 Private API 접근하기&lt;/h4&gt;

&lt;p&gt;위에서 살펴봤듯이 VPC Endpoint 설정시 프라이빗 DNS 이름을 활성화 한 경우 https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com 주소로 VPC 내부서버에서는 API call이 가능합니다. 아래처럼 VPC 내부 서버에서 nslookup을 수행하면 IP resolve가 잘 되는 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ubuntu@ec2-instance:/$ nslookup https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com
Server:    127.0.0.53
Address:  127.0.0.53#53

Non-authoritative answer:
https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com  canonical name = execute-api.ap-northeast-1.amazonaws.com.
Name:  execute-api.ap-northeast-1.amazonaws.com
Address: 172.31.86.18
Name:  execute-api.ap-northeast-1.amazonaws.com
Address: 172.31.2.179
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;비슷하게도 VPC내에 위치한 VPN 서버를 통해 VPN연결을 하게되면 VPC내부에 있는 것과 동일하게 간주되서 Private API를 호출하는 것이 가능해집니다. (반대로 말하면 VPN연결 없이는 개발자의 컴퓨터에서 Private API를 호출하는 것이 불가능합니다.)
VPN이 연결된 상태로 nslookup을 수행하면 별다른 설정 없이 위의 VPC내부의 서버에서처럼 동일하게 IP resolve가 잘 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://forums.aws.amazon.com/thread.jspa?threadID=161982&quot;&gt;AWS forum에 올라온 글&lt;/a&gt;을 보면 DNS forward를 별도로 설정하지 않으면 VPC DNS에 접근이 안된다고 나와있긴한데, 실제로 SoftEther VPN의 기본설정값으로 VPN연결 후에 사용했지만 VPC Private 도메인들도 resolve가 잘되는 것을 확인했습니다.&lt;/p&gt;

&lt;h4 id=&quot;참고-2-vpc의-private-dns-접근이-실패하는-경우-트러블-슈팅&quot;&gt;참고 2: VPC의 Private DNS 접근이 실패하는 경우 트러블 슈팅&lt;/h4&gt;

&lt;p&gt;혹시 VPN연결의 DNS 설정이 잘못된 경우 VPC내에 존재하는 VPN을 통해서 접근했는데도 DNS Resolve가 되지 않아서 접근이 불가능해지는 경우가 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yjiq150@local-pc:/$ nslookup zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com
Server:    8.8.8.8
Address:  8.8.8.8#53

** server can't find https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com: SERVFAIL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VPN Client의 VPN (L2TP) 연결 설정에서 VPN 서버가 제공한 DNS 정보를 사용하지 않고 별도로 DNS 서버의 주소를 설정해서 DNS설정이 override된 경우 (ex: 8.8.8.8, 4.4.4.4 등의 구글에서 제공하는 DNS를 등록해 두는 경우가 존재) VPC의 private DNS쪽으로 DNS query 가 전달되지 않아서 IP resolve가 실패가 발생합니다.&lt;/p&gt;

&lt;p&gt;Mac 사용자라면 VPN에 연결된 상태로 경우 네트워크 설정(Network Preference) 메뉴에 들어가서 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPN L2TP&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;DNS&lt;/code&gt; 에 접근하여 수동으로 설정된 DNS 서버주소를 모두 삭제하면 문제가 해결됩니다.&lt;/p&gt;

&lt;h3 id=&quot;2-public-엔드포인트-endpoint를-이용한-내부-서비스-구성&quot;&gt;2. Public 엔드포인트 Endpoint를 이용한 내부 서비스 구성&lt;/h3&gt;

&lt;p&gt;내부에서만 사용하는 API라면 private 엔드포인트를 통해서도 사용하지만, 해당 API가 VPC내부에서도 호출되고 외부에서도 동시에 호출되어야 하는 경우도 종종 있는데 이 경우 private 엔드포인트만으로는 불편합니다.&lt;/p&gt;

&lt;p&gt;이 경우 API를 Public(Regional/Edge) 엔드포인트 형태로 생성한 후 다음과 같은 옵션들을 이용해서 접근 제어가 가능합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;API GW에 API Key를 생성하고, 해당 API Key를 넣어서 호출해야 접근 가능하도록 설정
    &lt;ul&gt;
      &lt;li&gt;method별로 다른 API Key를 설정 가능&lt;/li&gt;
      &lt;li&gt;하나의 method에 여러개의 다른 API key를 설정 가능&lt;/li&gt;
      &lt;li&gt;API key 별로 사용량 계획(usage plan)을 할당해서 과도한 호출 제한 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순 허용/비허용만 가능한 인증 외에 더 디테일한 권한 체크를 하려면 API GW에 권한부여자(custom authorizer)를 사용 필요
    &lt;ul&gt;
      &lt;li&gt;권한 체크용 Lambda 함수를 통해서 조건에따라 접근 허용할지 여부를 결정 가능&lt;/li&gt;
      &lt;li&gt;별도 Lambda 함수 구현 없이 AWS Cognito의 사용자 풀을 이용해서 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API GW의 리소스 정책(Resource Policy) 설정을 이용하면 IP기반으로도 whitelist/blacklist 액세스 컨트롤이 가능합니다. 하지만 VPC 내부에서 Public 엔드포인트를 호출하는 경우 API GW에 수신된 요청의 IP주소를 확인해 보면 해당 서버의 VPC 내의 private IP가 아닌 public IP 주소이기 때문에 VPC내의 private IP range를 이용한 액세스컨트롤은 불가능 합니다. 대신 개별 public IP를 각각 정확히 지정해야하는데, 동적으로 서버가 실행/종료되는 경우라서 IP가 계속 바뀌는 경우라면 설정이 어려워지는 문제가 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; API key의 경우 secret에 속하기때문에 보통 소스 저장소에 포함시키지 않는 것이 best practice입니다. secret의 갯수들이 많아지게 되면 별도 파일로 관리하는 것이 편리합니다. serverless.yml 파일 안에 Lamda의 환경변수(env variable)로 들어갈 secret 값들이 소스 저장소에 포함되지 않도록 외부 파일로 빼는 방법은 &lt;a href=&quot;https://serverless-stack.com/chapters/ko/load-secrets-from-env-yml.html&quot;&gt;Load secrets from env.yml&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;api-gatewaylambda-비용-분석-및-최적화&quot;&gt;API Gateway/Lambda 비용 분석 및 최적화&lt;/h2&gt;

&lt;p&gt;내부서비스를 serverless 형태로 로 기껏 만들어놨는데 직접 EC2 서버를 띄워서 만든것 보다 비용이 과도하게 비싸다면 그것또한 큰 문제이겠죠? 이부분이 궁금하신 분들을 위해서 어떻게하면 저렴하게 이용할 수 있고 대략적으로 비용이 얼마나 들지를 한번 분석해 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-api-gateway-비용&quot;&gt;1. API Gateway 비용&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/api-gateway/pricing&quot;&gt;API GW 요금 페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아래 나오는 호출 비용과 VPC Endpoint 비용이 걱정된다면 API GW를 통하지 않고 Lambda를 직접 호출하는 방식을 사용하는 것이 낫습니다. 대신 직접 호출의 경우 일반적인 HTTP호출이 불가능하고 AWS SDK를 통해서만 호출해야하는 불편함이 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;호출-비용&quot;&gt;호출 비용&lt;/h4&gt;

&lt;p&gt;Public/Private API 무관하게 REST API 방식으로 설정된 GW의 경우 월 100만 Request당 $4.25 정도의 비용이 발생합니다. 만약 사내 서비스 용도로 사용해서 호출이 그리 많지 않다면 비용은 거의 무시 가능할 것으로 예상됩니다.&lt;/p&gt;

&lt;p&gt;기존 REST API 방식이 아닌 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/compute/announcing-http-apis-for-amazon-api-gateway/&quot;&gt;2019년 12월에 새로 출시한 HTTP API 방식&lt;/a&gt;을 사용하면 100만 Request당 $1.29 로 더 저렴하게 사용할 수 있지만 아직 베타버전이고 지원하는 기능의 범위가 조금씩 다르니 잘 살펴보고 적용하면 좋을 것 같네요.&lt;/p&gt;

&lt;h4 id=&quot;private-api-사용을-위한-vpc-endpoint-비용&quot;&gt;Private API 사용을 위한 VPC Endpoint 비용&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/api-gateway/pricing&quot;&gt;API GW 요금 페이지&lt;/a&gt;를 보면 아래와같은 내용이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프라이빗 API에 대한 데이터 전송 요금은 없습니다. 하지만 Amazon API Gateway에서 프라이빗 API를 사용하는 경우에는 AWS PrivateLink 요금이 적용됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이에따라 API GW 요금과 별도로 VPC 엔드포인트를 생성한 순간 부터 Billing 내역 중 Virtual Private Cloud (VPC) 항목에 아래와같은 요금이 부과됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$0.01 per GB Data Processed by VPC Endpoints&lt;/li&gt;
  &lt;li&gt;$0.014 per VPC Endpoint Hour&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호출 양이 많지 않다면 데이터 전송요금은 부담이 없겠지만 VPC Endpoint가 생성되어있는 것 만으로도 한달에 10달러 정도가 소모되니 주의해야 할 부분 중에 하나입니다.&lt;/p&gt;

&lt;h4 id=&quot;사용량-계획usage-plan-적용을-통한-과도한-사용-방지&quot;&gt;사용량 계획(Usage Plan) 적용을 통한 과도한 사용 방지&lt;/h4&gt;

&lt;p&gt;API GW에서 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-request-throttling.html&quot;&gt;사용량 계획&lt;/a&gt;을 통해 스로틀(throttle)을 걸어두면 불필요하게 과도한 요청을 차단해서 비용을 절감할 수 있습니다. 스로틀은 토큰 버킷(Token Bucket) 알고리즘에 기반하여 동작하게 되는데, 사용량 계획의 두가지 설정 항목을 아래 처럼 생각 하면 이해하기 쉽습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버스트(Burst): 버킷의 크기&lt;/li&gt;
  &lt;li&gt;요율(Rate): 단위 시간당 버킷에 토큰이 채워지는 양&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[토큰 버킷 동작 방식]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API GW가 요청 하나를 처리할 때 마다 버킷안에 든 토큰을 하나 소모하게되고, 동시에 시간이 지남에따라 정해진 요율 만큼의 토큰이 다시 버킷에 채워집니다.&lt;/li&gt;
  &lt;li&gt;순간적으로 너무 요청이 많이 들어오는 경우 버킷안에 토큰이 모두 소모되게되고 토큰 소진 이후에 발생하는 요청들은 429 Too many Request 오류로 처리됩니다.&lt;/li&gt;
  &lt;li&gt;토큰이 소진되었어도 시간이 지나 요율에 따라 토큰이 채워지는 즉시, 신규 요청들을 정상적으로 처리합니다. (채워진 토큰의 양보다 신규 요청들이 많을경우 또 429 오류 발생 가능)&lt;/li&gt;
  &lt;li&gt;요청이 거의 없어서 버킷 안에 토큰이 가득차더라도 버킷 크기(=버스트) 이상으로 토큰이 늘어나지는 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-lambda-비용&quot;&gt;2. Lambda 비용&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/lambda/pricing/&quot;&gt;Lambda 요금 페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lambda의 경우 월 100만번 호출, 실행소요시간 400,000 GB-초 까지는 프리티어 여부와 무관하게 항상 무료로 사용가능합니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;GB-초&lt;/code&gt; 라는 단위가 재미있는데, 1GB-초 는 최대 1GB(1024MB)의 메모리를 사용하도록 설정된 Lambda 함수가 1초동안 실행된다는 의미입니다. 따라서 동일하게 1초동안 실행된 Lambda 함수여도 메모리 사용량이 512MB로 설정되어있었다면 0.5초 GB-초 만큼을 사용한 것으로 볼 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;lambda-실행-소요시간-최적화&quot;&gt;Lambda 실행 소요시간 최적화&lt;/h4&gt;
&lt;p&gt;Lambda 요금페이지를 보면 아래와같은 내용이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS Lambda 리소스 모델에서 함수에 사용할 메모리 양을 선택하면 이에 비례하여 CPU 용량과 기타 리소스가 할당됩니다. 메모리 크기가 증가하면 함수에 사용할 수 있는 CPU도 그만큼 증가하게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, Lambda 함수가 512MB의 메모리만 필요로 하더라도 CPU 사용량이 많은 작업을 수행하는 경우 오히려 실행 시간이 1024MB를 할당한 경우보다 2배이상 늘어나 버릴 수 있다는 이야기 입니다. 이런경우 비용을 줄이기 위해 메모리 사용량을 줄였지만, CPU 타임을 할당받지 못하여 오히려 실행 시간이 늘어나서 &lt;code class=&quot;highlighter-rouge&quot;&gt;GB-초&lt;/code&gt; 관점에서 봤을 때는 비용 효율이 떨어지게 되는 현상이 발생 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GB-초&lt;/code&gt; 비용 최적화를 위해 실제 호출을 처리할 때 사용한 메모리의 양과 요금 부과 시간(Billed Duration) 을 확인하고싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Lambda &amp;gt; 함수 선택 &amp;gt; 모니터링 탭 선택 &lt;/code&gt; 으로 진입하여 Recent Invocations 섹션을 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;메모리 할당량을 조정하면서 함수가 수행될 때의 요금 부과시간을 확인하면 자신의 함수에 맞는 최적값을 찾아낼 수 있을것이고 이를 통해 비용을 절약하는 것이 가능하니 시간날 때 열심히 최적화를 해보는 것도 좋을 것 같네요.&lt;/p&gt;

&lt;p&gt;Lambda에서의 메모리 할당량과 CPU 리소스 관계에 관한 좀더 자세한 내용은 &lt;a href=&quot;https://engineering.opsgenie.com/how-does-proportional-cpu-allocation-work-with-aws-lambda-41cd44da3cac&quot;&gt;여기를 참고&lt;/a&gt;하시면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;FAQ&lt;/h2&gt;

&lt;p&gt;AWS의 수 많은 서비스들과 설정값들을 보면 어떤 서비스를 어떻게 연결하다 보면 질문이 꼬리에 꼬리를 물고 생겨나는 것을 느껴본적이 있으실 것 같습니다. 제가 실제 사내 서비스를 배포하면서 생겼던 의문점들을 Q&amp;amp;A 형식으로 몇가지 정리해보았습니다.&lt;/p&gt;

&lt;h4 id=&quot;public-엔드포인트와-연결된-lambda-내부-코드에서-private-엔드포인트에-연결된-lambda를-호출하면-어떻게되나요&quot;&gt;Public 엔드포인트와 연결된 Lambda 내부 코드에서 Private 엔드포인트에 연결된 Lambda를 호출하면 어떻게되나요?&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getaddrinfo ENOTFOUND 0pylfo8d60.execute-api.ap-northeast-1.amazonaws.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 DNS resolve 에러가 발생하면서 호출이 불가능 합니다.
대신 Lambda 안에서 해당 사용중인 언어의 AWS SDK를 import하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;lambda.invoke&lt;/code&gt; 메서드를 사용하면 Lambda를 직접 호출하는 것은 가능하니 필요하다면 이 방법을 사용하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;private-엔드포인트에는-사용자-지정-도메인custom-domain을-연결-할-수-있을까요&quot;&gt;Private 엔드포인트에는 사용자 지정 도메인(custom domain)을 연결 할 수 있을까요?&lt;/h4&gt;

&lt;p&gt;2020년 1월 현재 AWS API Gateway에서는 지원해 주지 않는다. 꼭 필요한 경우 간단하진 않지만 아래와 같은 방식으로 해결이 가능합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VPC내부에 Reverse proxy server를 둬서 해당 proxy에 custom domain을 연결 한 후 proxy로 들어온 요청을 Private 엔드포인트로 포워딩 하는 방법&lt;/li&gt;
  &lt;li&gt;VPC내부 서버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 파일을 조작하거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;dnsmasq&lt;/code&gt;를 이용해서 custom domain이 Private 엔트포인트에 해당하는 주소로 resolve 되도록 하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;api-gw를-연결하지-않고-lambda를-실행이-가능한가요&quot;&gt;API GW를 연결하지 않고 Lambda를 실행이 가능한가요?&lt;/h4&gt;

&lt;p&gt;위에서도 언급했듯이 AWS SDK를 통해서 Lambda를 직접 호출할 수 있습니다. 하지만 일반적인 HTTP client를 통해 Lambda 함수를 실행하려면 API GW가 필수적입니다.&lt;/p&gt;

&lt;h4 id=&quot;lambda를-특정-vpc-컨텍스트-내에서-실행-가능한가요&quot;&gt;Lambda를 특정 VPC 컨텍스트 내에서 실행 가능한가요?&lt;/h4&gt;

&lt;p&gt;Lambda에서 VPC 내에서만 접근가능하도록 설정된 다른 AWS 서비스 (ex: EC2, RDS, ElastiCache 등)를 이용하려면
특정 VPC 에서 동작하도록 별도의 설정이 필요합니다. Serverless framework을 사용하는 경우 다음 &lt;a href=&quot;https://serverless.com/framework/docs/providers/aws/guide/functions#vpc-configuration&quot;&gt;VPC Configuration&lt;/a&gt;부분을 읽어봐 주세요.&lt;/p&gt;

&lt;h2 id=&quot;serverlessyml-sample&quot;&gt;Serverless.yml Sample&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://serverless.com/framework/docs/providers/aws/guide/serverless.yml/&quot;&gt;Serverless.yml Reference for AWS&lt;/a&gt; 문서를 보면 serverless framework을 이용하여 AWS 서비스들을 설정 할 수 있는 모든 파라미터들이 명시되어 있습니다. 필요한 설정이 있다면 여기를 제일 먼저 찾아보면 됩니다.&lt;/p&gt;

&lt;p&gt;모든 설정을 하나씩 검토하는 수고를 줄이기 위해 일단 스퀘어랩의 내부 서비스를 개발할때 사용했던 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 파일의 일부를 샘플로 공개하니 참고하세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# app and org for use with dashboard.serverless.com
app: general
org: squarelab

service: noticontrol

frameworkVersion: &quot;=1.60.1&quot;

plugins:
  - serverless-domain-manager # API GW 사용자 지정 도메인을 쉽게 설정할 수 있게 해주는 플러그인
custom:
  # Refer to https://serverless.com/blog/serverless-api-gateway-domain/
  # Checkout results: https://ap-northeast-1.console.aws.amazon.com/apigateway/home?region=ap-northeast-1#/custom-domain-names
  customDomain:
    domainName: ${self:service}.squarelab.co
    basePath: ''
    endpointType: regional
    stage: ${opt:stage}
    createRoute53Record: true

  # Load secrets from env.yml file (NOT included in repo)
  environment: ${file(env.yml)}

provider:
  name: aws
  runtime: nodejs10.x
  region: ap-northeast-1
  stage: ${opt:stage, 'local'}

  #
  # API Gateway configurations
  #
  # EDGE: Deploy API GW with cloudfront (default value)
  # REGIONAL: Deploy API GW without cloudfront
  # PRIVATE: Deploy private API GW (only accessible within VPC)
  endpointType: REGIONAL
  resourcePolicy:
    - Effect: Allow
      Principal: '*'
      Action: execute-api:Invoke
      Resource:
        - execute-api:/*
  apiKeys:
    - key_name # This will generate an api key on first deploy
  usagePlan:
    quota:
      limit: 500000
      period: MONTH
    throttle: # rq per second
      rateLimit: 5
      burstLimit: 10

  #
  # Lambda Configurations
  #
  memorySize: 256 # Default is 1024MB
  timeout: 4 # Default is 6 seconds (API Gateway maximum is 30)

  #
  # CloudWatch Loggings
  #
  logRetentionInDays: 14 # CloudWatch LogGroup retention period
  tracing:
    apiGateway: false
    lambda: false
  logs:
    restApi:
      accessLogging: false
      executionLogging: false # Configuration which enables or disables execution logging.
      fullExecutionData: false # Log rs/rq on error case (ex: non 2xx status codes)

  environment:
    SLACK_SIGNING_SECRET: ${self:custom.environment.slackSigningSecret}
    SLACK_API_TOKEN: ${self:custom.environment.slackApiToken}

functions:
  handleSlackMessage:
    handler: handler.handleSlackMessage
    events:
      - http:
          path: message
          method: post
          private: true # This makes API require apiKeys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 &lt;a href=&quot;https://yaml.org/faq.html&quot;&gt;YAML 공식 웹사이트&lt;/a&gt;에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; 확장자를 추천하고 있지만, 전통적으로 확장자는 3글자를 사용해왔던 컨벤션 때문에 프로젝트에따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yml&lt;/code&gt; 도 많이 사용되고 있습니다. 예를들어 쿠버네티스 설정파일의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt;을 사용하지만, serverless framework의 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yml&lt;/code&gt;을 사용하는 것에 주의하세요.&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Feb 2020 00:00:00 +0900</pubDate>
        <link>/blog/developing-internal-service-with-serverless-aws/</link>
        <guid isPermaLink="true">/blog/developing-internal-service-with-serverless-aws/</guid>
        
        
        <category>Engineering</category>
        
      </item>
    
  </channel>
</rss>
