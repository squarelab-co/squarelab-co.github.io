<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Square Lab</title>
    <description>새로운 시선으로 여행을 바라보는 사람들</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 06 Feb 2020 18:34:39 +0900</pubDate>
    <lastBuildDate>Thu, 06 Feb 2020 18:34:39 +0900</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Cloudinary를 활용한 이미지 컨텐츠 관리</title>
        <description>&lt;p&gt;새로운 서비스를 만들때 이미지 컨텐츠를 관리하는 것은 디자이너에게 매우 중요한 문제입니다. 디자인이 아무리 잘되어 있어도 컨텐츠가 적절한 퀄리티로 노출되지 않으면 디자인의 품질이 떨어져 보이고 사용자에게도 신뢰감을 주기 어렵기 때문입니다.&lt;/p&gt;

&lt;p&gt;그렇다고 모든 이미지 컨텐츠를 디자이너가 직접 관리하기에는 리소스가 너무 많이 들지요. 이 포스트에서는 스퀘어랩이 Cloudinary를 활용해 어떻게 이미지 컨텐츠를 관리하고 있는지 공유합니다.&lt;/p&gt;

&lt;h2 id=&quot;cloudinary-소개&quot;&gt;Cloudinary 소개&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloudinary.com/&quot;&gt;Cloudinary&lt;/a&gt;는 클라우드 기반의 이미지 및 비디오 관리 서비스입니다. 강력하면서 쉬운 API를 제공하고 있어 조금만 익숙해지면 컨텐츠를 매우 효율적으로 관리할 수 있습니다. 그리고 무엇보다 무료로 시작할 수 있어 스타트업에서 도입하기에 부담이 적습니다.&lt;/p&gt;

&lt;h3 id=&quot;데모-이미지&quot;&gt;데모 이미지&lt;/h3&gt;
&lt;p&gt;Cloudinary에 가입하고 이미지를 업로드 하는 것은 어렵지 않습니다. 일반적인 CDN이나 웹서버의 사용법과 유사하죠. 이미지를 업로드하면 고유한 URL을 얻을 수 있는데, 예제로 사용하기 위해 Cloudinary에서 데모로 제공하고 있는 이미지 중에 고양이 사진을 하나 골라봤습니다. 고양이는 언제나 옳으니까요.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원본은 3940x2540 사이즈의 고화질 이미지이고 용량은 1.6MB입니다. 일반적인 웹이나 앱 서비스에서 이런 고화질 이미지를 사용하는 경우는 거의 없습니다. 그래서 상황에 맞게 디자이너들이 직접 이미지를 리사이징하거나 CDN에서 API를 제공하는 경우 API를 통해 동적으로 리사이징해 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-리사이징&quot;&gt;이미지 리사이징&lt;/h3&gt;
&lt;p&gt;Cloudinary에서는 URL 파라미터를 통해 쉽게 이미지를 리사이징 할 수 있습니다. 바로 예제를 살펴볼까요.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;크고 무거웠던 원본 이미지에서 400x258 사이즈에 용량은 25KB로 줄어든 이미지를 확인할 수 있습니다. URL에서 어떤 부분이 달라졌는지 눈치 채셨나요? &lt;code class=&quot;highlighter-rouge&quot;&gt;sofa_cat.jpg&lt;/code&gt; 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;width=400&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;w_400&lt;/code&gt; 파라미터를 붙여 원본을 기준으로 비율에 맞게 가로 400px로 줄어든 이미지를 얻을 수 있습니다. CSS나 다른 방식으로 이미지를 줄여서 표시한게 아니라 jpg 파일 자체의 사이즈와 용량이 줄어들었다는 점이 중요하니다.&lt;/p&gt;

&lt;div class=&quot;spacing-40&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,h_400/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,h_400/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물론 가로 사이즈도 원하는 대로 추가할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;height=400&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;h_400&lt;/code&gt; 파라미터를 추가하면 위와 같이 이미지가 표시됩니다. 비율에 맞지 않는 사이즈를 입력했기 떄문에 이미지가 강제로 늘어나 고양이가 좀 놀란 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-크롭핑&quot;&gt;이미지 크롭핑&lt;/h3&gt;
&lt;p&gt;원본 비율과 다른 사이즈가 필요할 때는 이미지가 왜곡되어 보이지 않도록 이미지를 크롭해야 합니다. Cloudinary에서는 리사이징과 마찬가지로 URL 파라미터를 통해 쉽게 이미지를 크롭할 수 있습니다.
&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crop to fill&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;c_fill&lt;/code&gt;이 추가되었습니다. 이제 이미지 왜곡없이 400x400으로 이미지를 표시할 수 있게 되었습니다.&lt;/p&gt;

&lt;div class=&quot;spacing-40&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,ar_1:1,c_fill/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,ar_1:1,c_fill/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;height=400&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;h_400&lt;/code&gt; 대신 비율을 직접 입력할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;aspect ratio=1:1&lt;/code&gt;을 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ar_1:1&lt;/code&gt;을 사용해도 동일한 결과를 얻을 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;16:9&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;4:3&lt;/code&gt;등 원하는 비율대로 표시할 수 있져.&lt;/p&gt;

&lt;h3 id=&quot;오브젝트-중심의-이미지-크롭핑&quot;&gt;오브젝트 중심의 이미지 크롭핑&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill,g_auto/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_400,h_400,c_fill,g_auto/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 계속 왼쪽으로 쏠려있는 고양이가 마음 쓰이셨죠? 파라미터를 하나 더 추가해서 이 문제를 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이번에 추가된 파라미터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;grtavity&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;로 적용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;g_auto&lt;/code&gt;입니다. 직역하자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;중력 자동 적용&lt;/code&gt; 정도로 해석할 수 있는데요. Cloudinary에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;grtavity&lt;/code&gt; 파라미터를 통해 이미지에 포함된 얼굴이나 사물을 자동으로 인식해 오브젝트를 안정적으로 표시할 수 있는 기능을 제공하고 있습니다. 오브젝트가 많이 포함된 이미지가 아니라면 인식률도 높아서 사용하는데 무리가 없습니다.&lt;/p&gt;

&lt;div class=&quot;spacing-40&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한쪽으로 긴 사이즈의 이미지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;grtavity&lt;/code&gt; 성능을 확인해 볼까요? 위 이미지 처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;g_auto&lt;/code&gt; 파라미터가 없으면 이미지의 가운데를 기준으로 크롭핑되어 고양이의 얼굴을 볼 수 없습니다.&lt;/p&gt;

&lt;div class=&quot;spacing-40&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto/sofa_cat.jpg&quot; alt=&quot;sofa_cat.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://res.cloudinary.com/demo/image/upload/w_640,h_144,c_fill,g_auto/sofa_cat.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;g_auto&lt;/code&gt; 파라미터를 넣어주면 가로나 세로로 긴 사이즈의 이미지를 요청하더라도 오브젝트를 기준으로 크롭핑 되어 고양이의 얼굴을 볼 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;맺음말&quot;&gt;맺음말&lt;/h3&gt;
&lt;p&gt;지금까지 Cloudinary를 활용법을 간단하게 살펴보았습니다. 스퀘어랩에서는 실제로 실무에서 사용하고 있으며, 이를 통해 디자이너들은 이미지를 리사이징하는 반복작업에서 벗어나 더 창조적인 작업에 집중할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;Cloudinary에는 위에 언급 된 내용보다 더 많은 기능이 있으니 자세한 내용은 &lt;a href=&quot;https://cloudinary.com/documentation/image_transformations&quot;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;
</description>
        <pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/get-started-with-cloudinary</link>
        <guid isPermaLink="true">http://localhost:4000/blog/get-started-with-cloudinary</guid>
        
        
        <category>Design</category>
        
      </item>
    
      <item>
        <title>Serverless한 회사 내부 서비스 만들기</title>
        <description>&lt;p&gt;사내에서 사용되는 서비스의 경우 대중을 대상으로 하지 않기 때문에 사용량이 많지 않은 경우가 대부분이다. AWS Lambda를 사용하면 비용 절감뿐만 아니라 서버를 직접 관리하고 운영할 필요도 없기 때문에 안정적이고 편리하다. Lambda에서는 warm up 전의 첫 호출시 응답이 느린 cold start문제가 있긴하지만 오히려 사내 서비스의 경우 상대적으로 유저경험이 덜 중요하기때문에 cold start시에 잠깐 응답이 느려지는것 정도는 큰 문제가 아니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이제 실제로 serverless 형태로 회사 내부 서비스를 만드려면 어떻게 해야하는지 좀더 깊은 고민을 해보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;serverless-framework-소개&quot;&gt;Serverless framework 소개&lt;/h2&gt;

&lt;p&gt;AWS Lambda + AWS API Gateway를 이용하여 직접 서버 인스턴스를 띄우지 않고서도 서버 기능을 할 수 있다는 사실은 많이 알려진 사실이다. 하지만 막상 이걸 직접 설정 해보려고 하면 해야할 일이 산더미다. 실제 코드를 작성해서 Lambda에 업로드해야하고, Lambda를 누가 실행 할 수 있는지 적당한 권한을 설정해줘야 하며, API Gateway와 Lambda를 연결해줘야하고, 사용자 지정 도메인도 연결해줘야하며, CloudWatch 로그 설정도 … (중략). 슬슬 오히려 EC2 인스턴스를 그냥 띄워서 하던대로 하는게 낫지 않을까 생각이 들기 시작한다.&lt;/p&gt;

&lt;p&gt;하지만 위와 같은 AWS 웹 콘솔을 통한 복잡하고 반복적인 설정/배포 과정 대신 &lt;a href=&quot;https://serverless.com/&quot;&gt;serverless framework&lt;/a&gt;를 사용하면 설정 파일 하나로 언제든지 손쉽게 환경 생성/재배포가 가능해지고 해당 설정 내용을 소스 저장소에 올려서 공유 및 변경 내용 추적까지 가능해 진다.&lt;/p&gt;

&lt;p&gt;serverless framework CLI를 설치한 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 설정 파일을 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;sls deploy&lt;/code&gt; 명령어만 실행하면 설정파일에 정의된 대로 자동으로 서비스 설정/배포가 된다. (설정 파일의 실제 내용이 궁금한 분들은 글 제일 아래쪽의 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 샘플 섹션을 참고)&lt;/p&gt;

&lt;p&gt;Serverless framework의 경우 내부적으로 AWS CloudFormation 기능을 이용하여 Lambda, API Gateway의 자잘한 설정들을 변경하게되는데, AWS 콘솔을 통해서 변경 가능한 설정 항목들은 serverless framework의 설정파일에서도 거의 지원하고있다고 보면 된다. (심지어 AWS뿐만아니라 Azure, Google Cloud 등의 다른 cloud provider도 지원한다.)&lt;/p&gt;

&lt;p&gt;Serverless framework을 이용해서 골치아픈 인프라 설정 문제는 어느정도 해결되었으니, 어떻게하면 회사 내부 서비스에 적합한 구성을 할 수 있을지에 대해서 고민해 보자.&lt;/p&gt;

&lt;h2 id=&quot;api-gateway를-어떻게-설정할-것인가&quot;&gt;API Gateway를 어떻게 설정할 것인가?&lt;/h2&gt;

&lt;p&gt;API Gateway의 경우 원래 Public API만 제공되었는데 2018년 6월 이후로는 설정된 VPC에서만 접근가능하도록 할 수 있는 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/compute/introducing-amazon-api-gateway-private-endpoints/&quot;&gt;Private API 기능&lt;/a&gt;이 새롭게 제공되기 시작했다.&lt;/p&gt;

&lt;p&gt;이 글에서는 AWS Lambda + API Gateway를 조합하여 사내 서비스들에 사용하기 적합한 형태로&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VPC에서만 액세스 가능한 Private API를 만드는 방법&lt;/li&gt;
  &lt;li&gt;Public API 이지만 Gateway에 API 인증키를 추가해서 접근 제한을 하는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두가지에 대해 알아보고자 한다.&lt;/p&gt;

&lt;p&gt;각각에 대해 설명하기 전에 먼저 API Gateway 엔드포인트 유형에따라 어떤 차이점들이 있는지를 먼저 정리해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Edge (or Edge optimized)
    &lt;ul&gt;
      &lt;li&gt;CloudFront CDN&lt;/li&gt;
      &lt;li&gt;Public network에서 요청 &amp;gt; CloudFront &amp;gt; API Gateway &amp;gt; Lambda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Regional
    &lt;ul&gt;
      &lt;li&gt;CDN없는 일반적인 public API&lt;/li&gt;
      &lt;li&gt;Public network에서 요청 &amp;gt; API Gateway &amp;gt; Lambda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Private
    &lt;ul&gt;
      &lt;li&gt;엔드포인트를 생성한 VPC내에서만 접근 가능&lt;/li&gt;
      &lt;li&gt;Public network에서 요청 &amp;gt; 연결 불가&lt;/li&gt;
      &lt;li&gt;사용자 VPC내에서 요청 &amp;gt; VPC Endpoint &amp;gt; API Gateway &amp;gt; Lambda&lt;/li&gt;
      &lt;li&gt;주의: &lt;a href=&quot;https://stackoverflow.com/questions/56540149/how-do-i-define-a-custom-domain-name-for-my-amazon-api-gateway-api-with-private&quot;&gt;Private 엔드포인트는 API Gateway에 사용자 지정 도메인 (custom domain) 연결 불가&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자신의 현재 Endpoint가 어떤 유형으로 설정 되어있는지 확인하려면 API Gateway의 메인 페이지에 방문해서 API목록 중에서 “엔드포인트 유형” 컬럼을 확인하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;1-private-엔드포인트를-이용한-내부서비스-구성&quot;&gt;1. Private 엔드포인트를 이용한 내부서비스 구성&lt;/h3&gt;

&lt;p&gt;API Gateway는 AWS가 관리하는 서비스 (AWS fully-managed) 이기때문에 사용자의 VPC와는 다른 공간에 있다. 때문에
Private 형태로 Endpoint를 만들어 준 경우 API Gateway의 네트워크와 사용자의 VPC가 통신할 수 있도록 허용을 해줘야한다. “VPC Endpoint” 설정이 이 연결을 허용할 수 있도록 해준다.&lt;/p&gt;

&lt;h4 id=&quot;vpc-endpoint-설정-하기&quot;&gt;VPC Endpoint 설정 하기&lt;/h4&gt;

&lt;p&gt;VPC &amp;gt; Endpoint 메뉴로 이동하면 엔드포인트를 추가 할 수 있다. 아래 순서대로 설정해 나가면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의:&lt;/strong&gt; 이부분은 serverless.yaml에서 지원하지 않기때문에 AWS 콘솔을 통해서 진행해야한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VPC &amp;gt; API Gateway 연결
    &lt;ul&gt;
      &lt;li&gt;VPC Endpoint의 경우 API Gateway뿐만 아니라 AWS의 다른 관리형 서비스들에도 설정해서 사용하는 것이 가능하기때문에 다양한 서비스 목록들이 노출된다. API Gateway와 연결하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;com.amazonaws.{REGION}.execute-api&lt;/code&gt; 을 찾아서 선택하면 된다.&lt;/li&gt;
      &lt;li&gt;ex) com.amazonaws.ap-northeast-1.execute-api&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VPC 중 어떤 Subnet의 연결을 허용할지 설정
    &lt;ul&gt;
      &lt;li&gt;가용 영역별로 연결을 허용할 원하는 subnet을 선택하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프라이빗 DNS 이름 활성화&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;“프라이빗 DNS 이름 활성화” 가 되어있으면 기존 Public한 API Gateway &amp;gt; Lambda에서 액세스하던것과 동일한 형태의 URL로 VPC내에서 접근이 가능하다.
        &lt;ul&gt;
          &lt;li&gt;URL 형식: https://{API_ID}.execute-api.{region}.amazonaws.com&lt;/li&gt;
          &lt;li&gt;ex) https://qb53b9muav2.execute-api.ap-northeast-1.amazonaws.com&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;주의&lt;/strong&gt;: 프라이빗 DNS를 활성화 된 엔드포인트 설정이 완료되면 해당 &lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/api-gateway-vpc-connections/&quot;&gt;VPC에서 사용자 지정 도메인(custom domain)이 설정되지 않은 기존 Public(Edge/Regional) API Gateway로의 API 호출시 HTTP 403 Forbidden 이 발생&lt;/a&gt;한다.
        &lt;ul&gt;
          &lt;li&gt;예를들어 VPC내에서 &lt;strong&gt;Regional 또는 Edge&lt;/strong&gt;로 설정된 API GW의 엔드포인트인 https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com/prod/example 로 요청시 403 Forbidden 발생&lt;/li&gt;
          &lt;li&gt;하지만 “API GW Console &amp;gt; 사용자 지정 도메인” 메뉴를 사용하여 위 엔드포인트를 사용자 지정 도메인에 연결 후, VPC내에서 사용자 지정 도메인을 이용한 주소 (https://myservice.com/example)로 요청시  오류가 발생하지 않음&lt;/li&gt;
          &lt;li&gt;따라서 기존에 Public하게 API Gateway를 사용하는 서비스가 있고, 해당 서비스를 VPC에서 내부에서 호출하고 있다면, VPC엔드포인트를 설정하기 전에 꼭 해당 서비스들에 사용자 지정 도메인을 연결 완료해야 문제가 없다.&lt;/li&gt;
          &lt;li&gt;이런 현상이 발생하는 원인에 관해서는 &lt;a href=&quot;https://st-g.de/2019/07/be-careful-with-aws-private-api-gateway-endpoints&quot;&gt;여기&lt;/a&gt;를 참고하면 좋다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안그룹 설정 필요
    &lt;ul&gt;
      &lt;li&gt;VPC Endpoint &amp;gt; API Gateway로 전달되는 요청은 보통 HTTP 요청이니 inbound 443, 80 포트를 허용하는 보안그룹을 추가해 주면 된다. 별도로 다른 프로토콜이나 포트를 사용하고있다면 해당 포트를 허용하도록 설정해주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;주의&lt;/strong&gt;: VPC Endpoint의 경우 &lt;strong&gt;생성 후 사용하지 않더라도 계속 요금이 발생&lt;/strong&gt;한다. 자세한 내용은 글 마지막의 “요금 분석” 섹션을 참고 하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;api-gateway에서-api-생성-하기&quot;&gt;API Gateway에서 API 생성 하기&lt;/h4&gt;

&lt;p&gt;API Gateway 콘솔에서 API 생성시 REST API (Private) 으로 되어있는것을 선택해서 생성하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt;를 사용할 경우 provider.endpointType 항목을 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; 으로 설정한다.&lt;/p&gt;

&lt;h4 id=&quot;특정-vpc에서만-접근되도록-설정&quot;&gt;특정 VPC에서만 접근되도록 설정&lt;/h4&gt;

&lt;p&gt;여러개의 VPC를 사용중인경우 그중 원하는 VPC에서만 Internal API가 호출되도록 허용하고 싶은 경우가 있다. 이경우 API Gateway의 리소스 정책 메뉴에서 “소스 VPC 화이트리스트” 버튼을 눌러 정책 템플릿을 로드한 후 원하는 vpcID만 넣어주면 된다.  API GW의 경우 “리소스 정책” 설정 변경 후 항상 deploy를 눌러줘야 반영이 되니 주의해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 를 사용할 경우 provider.resourcePolicy에 해당 정책을 yaml형태로 넣어주면 된다.&lt;/p&gt;

&lt;h4 id=&quot;참고-1-vpn-연결을-통해서-vpc의-내부의-private-api-접근하기&quot;&gt;참고 1: VPN 연결을 통해서 VPC의 내부의 Private API 접근하기&lt;/h4&gt;

&lt;p&gt;위에서 살펴봤듯이 VPC Endpoint 설정시 프라이빗 DNS 이름을 활성화 한 경우 https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com 주소로 VPC 내부서버에서는 API call이 가능하다. VPC 내부 서버에서 nslookup을 수행하면 다음과같이 IP resolve가 잘 되는것을 확인 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ubuntu@ec2-instance:/$ nslookup https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com
Server:    127.0.0.53
Address:  127.0.0.53#53

Non-authoritative answer:
https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com  canonical name = execute-api.ap-northeast-1.amazonaws.com.
Name:  execute-api.ap-northeast-1.amazonaws.com
Address: 172.31.86.18
Name:  execute-api.ap-northeast-1.amazonaws.com
Address: 172.31.2.179
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;비슷하게도 VPC내에 위치한 VPN 서버를 통해 VPN연결을 하게되면 VPC내부에 있는것과 동일하게 간주되서 Private API를 호출하는것이 가능해진다. (반대로 말하면 VPN연결 없이는 개발자의 컴퓨터에서 Private API를 호출하는것이 불가능하다.)
VPN이 연결된 상태로 nslookup을 수행하면 별다른 설정 없이 위의 VPC내부의 서버에서처럼 동일하게 IP resolve가 잘 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://forums.aws.amazon.com/thread.jspa?threadID=161982&quot;&gt;AWS forum에 올라온 글&lt;/a&gt;을 보면 DNS forward를 별도로 설정하지 않으면 VPC DNS에 접근이 안된다고 나와있긴한데, 실제로 SoftEther VPN의 기본설정값으로 VPN연결후에 사용했지만 VPC Private 도메인들도 resolve가 잘되는 것을 확인했다.&lt;/p&gt;

&lt;h4 id=&quot;참고-2-vpc의-private-dns-접근이-실패하는-경우-트러블-슈팅&quot;&gt;참고 2: VPC의 Private DNS 접근이 실패하는 경우 트러블 슈팅&lt;/h4&gt;

&lt;p&gt;혹시 VPN연결의 DNS 설정이 잘못된 경우 VPC내에 존재하는 VPN을 통해서 접근했는데도 DNS Resolve가 되지 않아서 접근이 불가능해지는 경우가 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yjiq150@local-pc:/$ nslookup zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com
Server:    8.8.8.8
Address:  8.8.8.8#53

** server can't find https://zl5b9muyr1.execute-api.ap-northeast-1.amazonaws.com: SERVFAIL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VPN Client의 VPN (L2TP) 연결 설정에서 VPN 서버가 제공한 DNS 정보를 사용하지 않고 별도로 DNS 서버의 주소를 설정해서 DNS설정이 override된 경우 (ex: 8.8.8.8, 4.4.4.4 등의 구글에서 제공하는 DNS를 등록해 두는 경우가 존재) VPC의 private DNS쪽으로 DNS query 가 전달되지 않아서 IP resolve가 실패가 발생한다.&lt;/p&gt;

&lt;p&gt;Mac 사용자라면 VPN에 연결된 상태로 경우 네트워크 설정(Network Preference) 메뉴에 들어가서 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPN L2TP&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;DNS&lt;/code&gt; 에 접근하여 수동으로 설정된 DNS 서버주소를 모두 삭제하면 문제를 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-public-엔드포인트-endpoint를-이용한-내부-서비스-구성&quot;&gt;2. Public 엔드포인트 Endpoint를 이용한 내부 서비스 구성&lt;/h3&gt;

&lt;p&gt;내부에서만 사용하는 API라면 private 엔드포인트를 통해서도 사용하지만, 해당 API가 VPC내부에서도 호출되고 외부에서도 동시에 호출되어야 하는 경우도 종종 있는데 이 경우 private 엔드포인트만으로는 불편하다.&lt;/p&gt;

&lt;p&gt;이 경우 API를 Public(Regional/Edge) 엔드포인트 형태로 생성한 후 다음과 같은 옵션들을 이용해서 접근 제어를 할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;API GW에 API Key를 생성하고, 해당 API Key를 넣어서 호출해야 접근 가능하도록 설정
    &lt;ul&gt;
      &lt;li&gt;method별로 다른 API Key를 설정 가능&lt;/li&gt;
      &lt;li&gt;하나의 method에 여러개의 다른 API key를 설정 가능&lt;/li&gt;
      &lt;li&gt;API key 별로 사용량 계획(usage plan)을 할당해서 과도한 호출 제한 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순 허용/비허용만 가능한 인증 외에 더 디테일한 권한 체크를 하려면 API GW에 권한부여자(custom authorizer)를 사용해야한다.
    &lt;ul&gt;
      &lt;li&gt;권한 체크용 Lambda 함수를 통해서 조건에따라 접근 허용할지 여부를 결정 가능&lt;/li&gt;
      &lt;li&gt;별도 Lambda 함수 구현 없이 AWS Cognito의 사용자 풀을 이용해서 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API GW의 리소스 정책(Resource Policy) 설정을 이용하면 IP기반으로도 whitelist/blacklist 액세스 컨트롤이 가능하다. 하지만 VPC 내부에서 Public 엔드포인트를 호출하는 경우 API GW에 수신된 요청의 IP주소를 확인해 보면 해당 서버의 VPC 내의 private IP가 아닌 public IP 주소이기 때문에 VPC내의 private IP range를 이용한 액세스컨트롤은 불가능 하다. 대신 개별 public IP를 각각 정확히 지정해야하는데, 동적으로 서버가 실행/종료되는 경우라서 IP가 계속 바뀌는 경우라면 설정이 어려워지는 문제가 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; API key의 경우 secret에 속하기때문에 보통 소스 저장소에 포함시키지 않는다. secret의 갯수들이 많아지게 되면 별도 파일로 관리하는것이 편리하다. serverless.yml 파일 안에 Lamda의 환경변수(env variable)로 들어갈 secret 값들이 소스 저장소에 포함되지 않도록 외부 파일로 빼는 방법은 &lt;a href=&quot;https://serverless-stack.com/chapters/ko/load-secrets-from-env-yml.html&quot;&gt;Load secrets from env.yml&lt;/a&gt; 글을 참고하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;api-gatewaylambda-비용-분석-및-최적화&quot;&gt;API Gateway/Lambda 비용 분석 및 최적화&lt;/h2&gt;

&lt;p&gt;내부서비스를 serverless 형태로 로 기껏 만들어놨는데 직접 EC2 서버를 띄워서 만든것 보다 비용이 과도하게 비싸다면? 그것또한 큰 문제다. 어떻게하면 저렴하게 이용할 수 있고 대략적으로 비용이 얼마나 들지를 한번 분석해보았다.&lt;/p&gt;

&lt;h3 id=&quot;1-api-gateway-비용&quot;&gt;1. API Gateway 비용&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/api-gateway/pricing&quot;&gt;API GW 요금 페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아래 나오는 호출 비용과 VPC Endpoint 비용이 걱정된다면 API GW를 통하지 않고 Lambda를 직접 호출하는 방식을 사용하도록 하자. 대신 직접 호출의 경우 일반적인 HTTP호출이 불가능하고 AWS SDK를 통해서만 호출해야하는 불편함이 있다.&lt;/p&gt;

&lt;h4 id=&quot;호출-비용&quot;&gt;호출 비용&lt;/h4&gt;

&lt;p&gt;Public/Private API 무관하게 REST API 방식으로 설정된 GW의 경우 월 100만 Request당 $4.25 정도의 비용이 발생한다. 만약 사내 서비스 용도로 사용해서 호출이 그리 많지 않다면 비용은 거의 무시 가능하다.&lt;/p&gt;

&lt;p&gt;기존 REST API 방식이 아닌 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/compute/announcing-http-apis-for-amazon-api-gateway/&quot;&gt;2019년 12월에 새로 출시한 HTTP API 방식&lt;/a&gt;을 사용하면 100만 Request당 $1.29 로 더 저렴하게 사용할 수 있지만 아직 베타버전이고 지원하는 기능의 범위가 조금씩 다르니 잘 살펴보고 적용해야한다.&lt;/p&gt;

&lt;h4 id=&quot;private-api-사용을-위한-vpc-endpoint-비용&quot;&gt;Private API 사용을 위한 VPC Endpoint 비용&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/api-gateway/pricing&quot;&gt;API GW 요금 페이지&lt;/a&gt;를 보면 아래와같은 내용이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프라이빗 API에 대한 데이터 전송 요금은 없습니다. 하지만 Amazon API Gateway에서 프라이빗 API를 사용하는 경우에는 AWS PrivateLink 요금이 적용됩니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이에따라 API GW 요금과 별도로 VPC 엔드포인트를 생성한 순간 부터 Billing 내역 중 Virtual Private Cloud (VPC) 항목에 아래와같은 요금이 부과된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$0.01 per GB Data Processed by VPC Endpoints&lt;/li&gt;
  &lt;li&gt;$0.014 per VPC Endpoint Hour&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호출 양이 많지 않다면 데이터 전송요금은 부담이 없겠지만 VPC Endpoint가 생성되어있는것 만으로도 한달에 10달러 정도가 소모되니 주의하자.&lt;/p&gt;

&lt;h4 id=&quot;사용량-계획usage-plan-적용을-통한-과도한-사용-방지&quot;&gt;사용량 계획(Usage Plan) 적용을 통한 과도한 사용 방지&lt;/h4&gt;

&lt;p&gt;API GW에서 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-request-throttling.html&quot;&gt;사용량 계획&lt;/a&gt;을 통해 스로틀(throttle)을 걸어두면 불필요하게 과도한 요청을 차단해서 비용을 절감할 수 있다. 스로틀은 토큰 버킷(Token Bucket) 알고리즘에 기반하여 동작하게 되는데, 사용량 계획의 두가지 설정 항목을 아래 처럼 생각 하면 이해하기 쉽다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버스트(Burst): 버킷의 크기&lt;/li&gt;
  &lt;li&gt;요율(Rate): 단위 시간당 버킷에 토큰이 채워지는 양&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[토큰 버킷 동작 방식]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API GW가 요청 하나를 처리할 때 마다 버킷안에 든 토큰을 하나 소모하게되고, 동시에 시간이 지남에따라 정해진 요율 만큼의 토큰이 다시 버킷에 채워진다.&lt;/li&gt;
  &lt;li&gt;순간적으로 너무 요청이 많이 들어오는 경우 버킷안에 토큰이 모두 소모되게되고 토큰 소진 이후에 발생하는 요청들은 429 Too many Request 오류로 처리된다&lt;/li&gt;
  &lt;li&gt;토큰이 소진되었어도 시간이 지나 요율에 따라 토큰이 채워지는 즉시, 신규 요청들을 정상적으로 처리한다. (채워진 토큰의 양보다 신규 요청들이 많을경우 또 429 오류 발생 가능)&lt;/li&gt;
  &lt;li&gt;요청이 거의 없어서 버킷 안에 토큰이 가득차더라도 버킷 크기(=버스트) 이상으로 토큰이 늘어나지는 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-lambda-비용&quot;&gt;2. Lambda 비용&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/lambda/pricing/&quot;&gt;Lambda 요금 페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lambda의 경우 월 100만번 호출, 실행소요시간 400,000 GB-초 까지는 프리티어여부와 무관하게 항상 무료로 사용가능하다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;GB-초&lt;/code&gt; 라는 단위가 재미있는데, 1GB-초 는 최대 1GB(1024MB)의 메모리를 사용하도록 설정된 Lambda 함수가 1초동안 실행된다는 의미이다. 따라서 동일하게 1초동안 실행된 Lambda 함수여도 메모리 사용량이 512MB로 설정되어있었다면 0.5초 GB-초 만큼을 사용한 것으로 볼 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;lambda-실행-소요시간-최적화&quot;&gt;Lambda 실행 소요시간 최적화&lt;/h4&gt;
&lt;p&gt;Lambda 요금페이지를 보면 아래와같은 내용이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS Lambda 리소스 모델에서 함수에 사용할 메모리 양을 선택하면 이에 비례하여 CPU 용량과 기타 리소스가 할당됩니다. 메모리 크기가 증가하면 함수에 사용할 수 있는 CPU도 그만큼 증가하게 됩니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, Lambda 함수가 512MB의 메모리만 필요로 하더라도 CPU 사용량이 많은 작업을 수행하는 경우 오히려 실행 시간이 1024MB를 할당한 경우보다 2배이상 늘어나 버릴 수 있다. 이런경우 비용을 줄이기 위해 메모리 사용량을 줄였지만, CPU 타임을 할당받지 못하여 오히려 실행 시간이 늘어나서 &lt;code class=&quot;highlighter-rouge&quot;&gt;GB-초&lt;/code&gt; 관점에서 봤을 때는 비용 효율이 떨어지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GB-초&lt;/code&gt; 비용 최적화를 위해 실제 호출을 처리할 때 사용한 메모리의 양과 요금 부과 시간(Billed Duration) 을 확인하고싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Lambda &amp;gt; 함수 선택 &amp;gt; 모니터링 탭 선택 &lt;/code&gt; 으로 진입하여 Recent Invocations 섹션을 보면 된다.&lt;/p&gt;

&lt;p&gt;메모리 할당량을 조정하면서 함수가 수행될 때의 요금 부과시간을 확인하면 자신의 함수에 맞는 최적값을 찾아낼 수 있을것이고 이를 통해 비용을 절약 하는것이 가능하다.&lt;/p&gt;

&lt;p&gt;Lambda에서의 메모리 할당량과 CPU 리소스 관계에 관한 좀더 자세한 내용은 &lt;a href=&quot;https://engineering.opsgenie.com/how-does-proportional-cpu-allocation-work-with-aws-lambda-41cd44da3cac&quot;&gt;여기를 참고&lt;/a&gt;하도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;FAQ&lt;/h2&gt;

&lt;p&gt;AWS의 수 많은 서비스들과 설정값들을 보면 어떤 서비스를 어떻게 연결하다 보면 질문이 꼬리에 꼬리를 문다. 실제 사내 서비스를 배포하면서 생겼던 의문점들을 몇가지 정리해보았다.&lt;/p&gt;

&lt;h4 id=&quot;public-엔드포인트와-연결된-lambda-내부-코드에서-private-엔드포인트에-연결된-lambda를-호출하면-어떻게되나&quot;&gt;Public 엔드포인트와 연결된 Lambda 내부 코드에서 Private 엔드포인트에 연결된 Lambda를 호출하면 어떻게되나?&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getaddrinfo ENOTFOUND 0pylfo8d60.execute-api.ap-northeast-1.amazonaws.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 DNS resolve 에러가 발생하면서 호출이 불가능 하다.
대신 Lambda 안에서 해당 사용중인 언어의 AWS SDK를 import하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;lambda.invoke&lt;/code&gt; 메서드를 사용하면 Lambda를 직접 호출하는것은 가능하니 필요하다면 이 방법을 사용하자.&lt;/p&gt;

&lt;h4 id=&quot;private-엔드포인트에는-사용자-지정-도메인custom-domain을-연결-할-수-있나&quot;&gt;Private 엔드포인트에는 사용자 지정 도메인(custom domain)을 연결 할 수 있나?&lt;/h4&gt;

&lt;p&gt;2020년 1월 현재 AWS API Gateway에서는 지원해 주지 않는다. 꼭 필요한 경우 간단하진 않지만 아래와 같은 방식으로 해결이 가능하긴 하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VPC내부에 Reverse proxy server를 둬서 해당 proxy에 custom domain을 연결 한 후 proxy로 들어온 요청을 Private 엔드포인트로 포워딩 하는 방법&lt;/li&gt;
  &lt;li&gt;VPC내부 서버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 파일을 조작하거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;dnsmasq&lt;/code&gt;를 이용해서 custom domain이 Private 엔트포인트에 해당하는 주소로 resolve 되도록 하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;api-gw를-연결하지-않고-lambda를-실행이-가능한가&quot;&gt;API GW를 연결하지 않고 Lambda를 실행이 가능한가?&lt;/h4&gt;

&lt;p&gt;위에서도 언급했듯이 AWS SDK를 통해서 Lambda를 직접 호출할 수 있다. 하지만 일반적인 HTTP client를 통해 Lambda 함수를 실행하려면 API GW가 필수적이다.&lt;/p&gt;

&lt;h4 id=&quot;lambda를-특정-vpc-컨텍스트-내에서-실행-가능한가&quot;&gt;Lambda를 특정 VPC 컨텍스트 내에서 실행 가능한가?&lt;/h4&gt;

&lt;p&gt;Lambda에서 VPC 내에서만 접근가능하도록 설정된 다른 AWS 서비스 (ex: EC2, RDS, ElastiCache 등)를 이용하려면
특정 VPC 에서 동작하도록 별도의 설정이 필요하다. Serverless framework을 사용하는 경우 다음 &lt;a href=&quot;https://serverless.com/framework/docs/providers/aws/guide/functions#vpc-configuration&quot;&gt;VPC Configuration&lt;/a&gt;부분을 읽어보면 된다.&lt;/p&gt;

&lt;h2 id=&quot;serverlessyml-sample&quot;&gt;Serverless.yml Sample&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://serverless.com/framework/docs/providers/aws/guide/serverless.yml/&quot;&gt;Serverless.yml Reference for AWS&lt;/a&gt; 문서를 보면 serverless framework을 이용하여 AWS 서비스들을 설정 할 수 있는 모든 파라메터들이 명시되어있다. 필요한 설정이 있다면 여기를 제일 먼저 찾아보면 된다.&lt;/p&gt;

&lt;p&gt;모든 설정을 하나씩 검토하는 수고를 줄이기 위해 일단 스퀘어랩의 내부 서비스를 개발할때 사용했던 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverless.yml&lt;/code&gt; 파일의 일부를 샘플로 공개한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# app and org for use with dashboard.serverless.com
app: general
org: squarelab

service: noticontrol

frameworkVersion: &quot;=1.60.1&quot;

plugins:
  - serverless-domain-manager # API GW 사용자 지정 도메인을 쉽게 설정할 수 있게 해주는 플러그인
custom:
  # Refer to https://serverless.com/blog/serverless-api-gateway-domain/
  # Checkout results: https://ap-northeast-1.console.aws.amazon.com/apigateway/home?region=ap-northeast-1#/custom-domain-names
  customDomain:
    domainName: ${self:service}.squarelab.co
    basePath: ''
    endpointType: regional
    stage: ${opt:stage}
    createRoute53Record: true

  # Load secrets from env.yml file (NOT included in repo)
  environment: ${file(env.yml)}

provider:
  name: aws
  runtime: nodejs10.x
  region: ap-northeast-1
  stage: ${opt:stage, 'local'}

  #
  # API Gateway configurations
  #
  # EDGE: Deploy API GW with cloudfront (default value)
  # REGIONAL: Deploy API GW without cloudfront
  # PRIVATE: Deploy private API GW (only accessible within VPC)
  endpointType: REGIONAL
  resourcePolicy:
    - Effect: Allow
      Principal: '*'
      Action: execute-api:Invoke
      Resource:
        - execute-api:/*
  apiKeys:
    - key_name # This will generate an api key on first deploy
  usagePlan:
    quota:
      limit: 500000
      period: MONTH
    throttle: # rq per second
      rateLimit: 5
      burstLimit: 10

  #
  # Lambda Configurations
  #
  memorySize: 256 # Default is 1024MB
  timeout: 4 # Default is 6 seconds (API Gateway maximum is 30)

  #
  # CloudWatch Loggings
  #
  logRetentionInDays: 14 # CloudWatch LogGroup retention period
  tracing:
    apiGateway: false
    lambda: false
  logs:
    restApi:
      accessLogging: false
      executionLogging: false # Configuration which enables or disables execution logging.
      fullExecutionData: false # Log rs/rq on error case (ex: non 2xx status codes)

  environment:
    SLACK_SIGNING_SECRET: ${self:custom.environment.slackSigningSecret}
    SLACK_API_TOKEN: ${self:custom.environment.slackApiToken}

functions:
  handleSlackMessage:
    handler: handler.handleSlackMessage
    events:
      - http:
          path: message
          method: post
          private: true # This makes API require apiKeys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 &lt;a href=&quot;https://yaml.org/faq.html&quot;&gt;YAML 공식 웹사이트&lt;/a&gt;에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; 확장자를 추천하고 있지만, 전통적으로 확장자는 3글자를 사용해왔던 컨벤션 때문에 프로젝트에따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yml&lt;/code&gt; 도 많이 사용되고있다. 예를들어 쿠버네티스 설정파일의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; 사용하지만, serverless framework의 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yml&lt;/code&gt;을 사용하는 것에 주의하자.&lt;/p&gt;

</description>
        <pubDate>Tue, 04 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/developing-internal-service-with-serverless-aws</link>
        <guid isPermaLink="true">http://localhost:4000/blog/developing-internal-service-with-serverless-aws</guid>
        
        
        <category>Engeeniring</category>
        
      </item>
    
  </channel>
</rss>
